#include <stdint.h>
#include <stdio.h>

// 0st byte: index in enum pins. 1nd byte: index in register array.
// Last bit HIGH (on the left end) indicates if it has an associated pwm clock pin.
enum pins
{
    a,
    b,
    c,
    d,
};

typedef struct _pin_extra_info
{
    uint8_t compare_reg_index;
    uint8_t pwm_inverting_mode_bits_offsets;
} pin_extra_info;

uint8_t* comp_regs[] = {
    1234U,
    5678U
};

pin_extra_info pina_info;
pin_extra_info pinc_info;


pin_extra_info* pins_extra_info[4];

uint8_t comp_reg_exists(enum pins pin)
{
    pin_extra_info* extra_info = pins_extra_info[(uint8_t) pin];
    if(extra_info)
    {
        if(extra_info->compare_reg_index <= (sizeof(comp_regs)/sizeof(comp_regs[0])) -1)
        {
            return 1;
        }
    }

    return 0;
}

volatile uint8_t* resolve_compare_reg(enum pins pin_mcu)
{
    // uint8_t index = read_compare_reg_index(pin_mcu);
    uint8_t index = (pins_extra_info[(uint8_t) pin_mcu])->compare_reg_index;
    return comp_regs[index];
}

uint8_t resolve_pwm_inverting_mode_bits_offset_container(enum pins pin_mcu)
{
    // // Find the index of the corresponding compare register.
    // uint8_t index = read_compare_reg_index(pin_mcu);
    // return pwm_inverting_mode_bits[index];

    return (pins_extra_info[(uint8_t) pin_mcu])->pwm_inverting_mode_bits_offsets;
}

uint8_t read_pwm_inverting_mode_bits_offset(enum pins pin_mcu, uint8_t* inverting_bits_offsets)
{
    uint8_t bits_offsets_container = resolve_pwm_inverting_mode_bits_offset_container(pin_mcu);
    
    // Search for the 0th bit first.
    uint8_t num_offsets = sizeof(inverting_bits_offsets)/sizeof(inverting_bits_offsets[0]);
    if(num_offsets == 0)
    {
        return 0;
    }

    uint8_t offset_current = 0;
    // Loop through all bits:
    for(uint8_t bit_current = 0; bit_current < 8; ++bit_current)
    {    // Check current bit is 1:
        if( (1<<bit_current & bits_offsets_container) >> bit_current )
        {
            inverting_bits_offsets[offset_current] = bit_current;
            ++offset_current;
        }
    }

    return 1;
}

void main(void)
{
    enum pins pina = a;
    enum pins pinb = b;
    enum pins pinc = c;

    pin_extra_info pina_info;
    pin_extra_info pinc_info;
    pina_info.compare_reg_index = 0;
    pina_info.pwm_inverting_mode_bits_offsets = 1<<7 | 1<<6;
    pinc_info.compare_reg_index = 1;
    pinc_info.pwm_inverting_mode_bits_offsets = 1<<5 | 1<<4;


    pins_extra_info[0] = &pina_info;
    pins_extra_info[1] = 0;
    pins_extra_info[2] = &pinc_info;
    pins_extra_info[3] = 0;

    volatile uint8_t* pina_comp_reg = resolve_compare_reg(pina);
    if(!comp_reg_exists(pina))
    {
        printf("Pin a doesn't have extra info!\n");
    }
    if(!comp_reg_exists(pinb))
    {
        printf("Pin b doesn't have extra info!\n");
    }
    
    volatile uint8_t* pinc_comp_reg = resolve_compare_reg(pinc);

    printf("Pin 'a' has a compare register: address = %p\n", pina_comp_reg);
    printf("Pin 'c' has a compare register: address = %p\n", pinc_comp_reg);


    uint8_t pwm_inverting_mode_offsets[2];
    read_pwm_inverting_mode_bits_offset(pina, pwm_inverting_mode_offsets);
    printf("For pin 'a': offset 0 = %d and offset 1 = %d\n", pwm_inverting_mode_offsets[0], pwm_inverting_mode_offsets[1]);
}